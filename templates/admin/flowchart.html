{% extends "admin/base.html" %}

{% block title %}Mapa de Fluxo - Administração{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <div class="card shadow">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <h2 class="card-title">Mapa de Fluxo da História</h2>
                    <div class="controls">
                        <div class="btn-group me-2">
                            <button class="btn btn-primary" id="moveUp" title="Mover para cima"><i class="bi bi-arrow-up"></i></button>
                        </div>
                        <div class="btn-group me-2">
                            <button class="btn btn-primary" id="moveLeft" title="Mover para esquerda"><i class="bi bi-arrow-left"></i></button>
                            <button class="btn btn-primary" id="moveDown" title="Mover para baixo"><i class="bi bi-arrow-down"></i></button>
                            <button class="btn btn-primary" id="moveRight" title="Mover para direita"><i class="bi bi-arrow-right"></i></button>
                        </div>
                        <div class="btn-group">
                            <button class="btn btn-primary" id="zoomIn" title="Aumentar zoom"><i class="bi bi-zoom-in"></i></button>
                            <button class="btn btn-primary" id="zoomOut" title="Diminuir zoom"><i class="bi bi-zoom-out"></i></button>
                            <button class="btn btn-primary" id="resetView" title="Resetar visualização"><i class="bi bi-arrows-angle-expand"></i></button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="card shadow mb-4">
    <div class="card-header bg-dark">
        <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0 text-white">Visualização do Fluxo</h5>
            <div class="btn-group">
                <button class="btn btn-outline-light btn-sm active" onclick="toggleFilter('all')">Todos</button>
                <button class="btn btn-outline-light btn-sm" onclick="toggleFilter('battle')">Batalhas</button>
                <button class="btn btn-outline-light btn-sm" onclick="toggleFilter('choice')">Escolhas</button>
                <button class="btn btn-outline-light btn-sm" onclick="toggleFilter('end')">Finais</button>
            </div>
        </div>
    </div>
    <div class="card-body">
        <canvas id="flowchart" width="1200" height="800"></canvas>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    const nodes = {{ nodes|tojson|safe }};
    let canvas, ctx;
    let scale = 1;
    let offsetX = 0, offsetY = 0;
    let filter = 'all';

    class Node {
        constructor(id, data, x, y) {
            this.id = id;
            this.data = data;
            this.x = x;
            this.y = y;
            this.width = 180;
            this.height = 90;
            this.connections = [];
        }

        draw(ctx) {
            if (filter !== 'all') {
                if (filter === 'battle' && !this.data.battle) return;
                if (filter === 'choice' && !this.data.choices) return;
                if (filter === 'end' && !this.data.end) return;
            }

            ctx.save();
            ctx.fillStyle = this.getColor();
            ctx.strokeStyle = this.getColor();
            ctx.lineWidth = 2;

            // Draw node box
            ctx.beginPath();
            ctx.roundRect(this.x, this.y, this.width, this.height, 10);
            ctx.fill();
            ctx.stroke();

            // Draw text
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            // Display numeric ID and Title
            ctx.font = '12px Arial';
            ctx.fillText(`ID: ${this.id}`, this.x + this.width/2, this.y + 20);
            
            if (this.data.title) {
                ctx.font = '11px Arial';
                let title = this.data.title;
                if (title.length > 20) {
                    title = title.substring(0, 20) + '...';
                }
                ctx.fillText(title, this.x + this.width/2, this.y + 40);
            }
        }

        getColor() {
            if (this.data.battle) return '#ff6b6b';
            if (this.data.end) return '#51cf66';
            if (this.data.choices) return '#339af0';
            return '#495057';
        }
    }

    function drawArrow(ctx, fromX, fromY, toX, toY, text) {
        // Calculate control points for curved lines
        const dx = toX - fromX;
        const dy = toY - fromY;
        const midX = fromX + dx * 0.5;
        const midY = fromY + dy * 0.5;
        
        // Draw curved arrow
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.quadraticCurveTo(midX, fromY, toX, toY);
        ctx.stroke();

        // Arrow head
        const angle = Math.atan2(toY - fromY, toX - fromX);
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - 10 * Math.cos(angle - Math.PI/6), toY - 10 * Math.sin(angle - Math.PI/6));
        ctx.lineTo(toX - 10 * Math.cos(angle + Math.PI/6), toY - 10 * Math.sin(angle + Math.PI/6));
        ctx.closePath();
        ctx.fill();

        // Connection text
        if (text) {
            ctx.save();
            ctx.fillStyle = '#fff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2;
            ctx.fillText(text, midX, midY - 5);
            ctx.restore();
        }
    }

    function initializeFlowchart() {
        canvas = document.getElementById('flowchart');
        ctx = canvas.getContext('2d');

        // Create node objects with better spacing
        const nodeObjects = [];
        let x = 50, y = 50;
        let maxNodesPerRow = 4;
        
        Object.entries(nodes).forEach(([id, data], index) => {
            if (index > 0 && index % maxNodesPerRow === 0) {
                y += 200;
                x = 50;
            }
            nodeObjects.push(new Node(id, data, x, y));
            x += 250;
        });

        function render() {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Apply transformations
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            // Draw connections
            ctx.strokeStyle = '#fff';
            nodeObjects.forEach(node => {
                if (node.data.next_node) {
                    const targetNode = nodeObjects.find(n => n.id === node.data.next_node);
                    if (targetNode) {
                        drawArrow(ctx, 
                            node.x + node.width, node.y + node.height/2,
                            targetNode.x, targetNode.y + targetNode.height/2);
                    }
                }
                if (node.data.choices) {
                    node.data.choices.forEach(choice => {
                        const targetNode = nodeObjects.find(n => n.id === choice.next_node);
                        if (targetNode) {
                            drawArrow(ctx,
                                node.x + node.width, node.y + node.height/2,
                                targetNode.x, targetNode.y + targetNode.height/2,
                                choice.text.substring(0, 15) + '...');
                        }
                    });
                }
            });

            // Draw nodes
            nodeObjects.forEach(node => node.draw(ctx));

            ctx.restore();
        }

        // Controls
        const moveStep = 50;
        
        document.getElementById('zoomIn').onclick = () => {
            scale *= 1.2;
            render();
        };

        document.getElementById('zoomOut').onclick = () => {
            scale *= 0.8;
            render();
        };

        document.getElementById('resetView').onclick = () => {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            render();
        };

        document.getElementById('moveUp').onclick = () => {
            offsetY += moveStep;
            render();
        };

        document.getElementById('moveDown').onclick = () => {
            offsetY -= moveStep;
            render();
        };

        document.getElementById('moveLeft').onclick = () => {
            offsetX += moveStep;
            render();
        };

        document.getElementById('moveRight').onclick = () => {
            offsetX -= moveStep;
            render();
        };

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') {
                offsetY += moveStep;
                render();
            } else if (e.key === 'ArrowDown') {
                offsetY -= moveStep;
                render();
            } else if (e.key === 'ArrowLeft') {
                offsetX += moveStep;
                render();
            } else if (e.key === 'ArrowRight') {
                offsetX -= moveStep;
                render();
            } else if (e.key === '+' || e.key === '=') {
                scale *= 1.2;
                render();
            } else if (e.key === '-') {
                scale *= 0.8;
                render();
            } else if (e.key === 'r') {
                scale = 1;
                offsetX = 0;
                offsetY = 0;
                render();
            }
        });

        // Pan functionality
        let isDragging = false;
        let startX, startY;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX - offsetX;
            startY = e.clientY - offsetY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                offsetX = e.clientX - startX;
                offsetY = e.clientY - startY;
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Initial render
        render();

        // Export toggle function
        window.toggleFilter = function(newFilter) {
            filter = newFilter;
            render();
        };
    }

    document.addEventListener('DOMContentLoaded', initializeFlowchart);
</script>

<style>
    #flowchart {
        width: 100%;
        height: 800px;
        background: #212529;
    }

    .btn-group .btn.active {
        background-color: #fff;
        color: #212529;
    }
</style>
{% endblock %}